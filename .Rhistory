ds <- read_xlsx("C:/Users/beabo/OneDrive/Documents/NAU/Misc/Lexie Aa Dark Light 2024/Data 2.xlsx", sheet = 4)
ds <- clean_names(ds)%>%
mutate(Mass_Gained = post_drying_mass_filter_and_fungi_g - filter_mass_g - 0.025)
ds %>%
ggplot(aes(x = condition, y = Mass_Gained, fill = condition))+
geom_boxplot()+
scale_x_discrete(labels = c('Ammonium Sulfate', "Urea"))+
stat_n_text()+
# stat_compare_means(method = "anova")+
geom_point(aes(shape = condition))+
theme(legend.position = "none")+
labs(y = "Fungal Mass Gained", x = "Nitrogen Type")
library(readxl)
library(dplyr)
library(janitor)
library(ggplot2)
library(EnvStats)
theme_set(theme_bw())
ds <- read_xlsx("Org_Inorg_N.xlsx", sheet = 2)
library(sf)
library(TerraClimR)
library(openxlsx)
# Coordinates of interest
coords <- data.frame(
lon = -112.8432663,  # Longitude
lat = 34.92349559    # Latitude
)
library(climateR)
# Coordinates of interest
coords <- data.frame(
lon = -112.8432663,  # Longitude
lat = 34.92349559    # Latitude
)
# Convert coordinates to an sf object
coords_sf <- st_as_sf(coords, coords = c("lon", "lat"), crs = 4326)  # Assuming WGS 84
# Function to process climatic variables
process_climatic_variable <- function(data, var_name) {
var_data <- as.data.frame(data[[var_name]])
averages <- colMeans(var_data, na.rm = TRUE)
averages_row <- as.data.frame(t(averages))
long_data <- averages_row %>%
pivot_longer(
cols = everything(),
names_to = "date_total",
values_to = var_name
) %>%
separate(date_total, into = c("var", "date"), sep = "_") %>%
mutate(date = as.Date(date)) %>%
mutate(year = format(date, "%Y"),
month = format(date, "%m"),
day = format(date, "%d")) %>%
select(-var, -date)
return(long_data)
}
# Query TerraClim data for the coordinates
ic <- getTerraClim(coords_sf, startDate = "2019-01-01", endDate = "2023-01-01")
View(ic)
# Query TerraClim data for the coordinates
ic <- getTerraClim(coords_sf, startDate = "2019-01-01", endDate = "2024-12-12")
# List of climatic variables
variables <- c("aet", "def", "PDSI", "pet", "ppt", "q", "soil", "srad", "swe", "tmax", "tmin", "vap", "vpd", "ws")
results_list <- list()
# Process each climatic variable
for (var in variables) {
results_list[[var]] <- process_climatic_variable(ic, var)
}
# Query TerraClim data for the coordinates
ic <- getTerraClim(coords_sf, startDate = "2018-01-01", endDate = "2024-12-01")
clim_summary <- ic %>%
mutate(
year = format(date, "%Y"),
month = format(date, "%m"),
day = format(date, "%d")
) %>%
group_by(year)%>%
summarise(across(
c(colnames(ic)),
list(
min = ~ min(.x, na.rm = TRUE),
max = ~ max(.x, na.rm = TRUE),
avg = ~ mean(.x, na.rm = TRUE),
med = ~ median(.x, na.rm = T)
),
.names = "{.col}_{.fn}"
))
library(tidyr)
library(dplyr)
long_data <- averages_row %>%
pivot_longer(
cols = everything(),
names_to = "date_total",
values_to = var_name
) %>%
separate(date_total, into = c("var", "date"), sep = "_") %>%
mutate(date = as.Date(date)) %>%
mutate(year = format(date, "%Y"),
month = format(date, "%m"),
day = format(date, "%d")) %>%
select(-var, -date)
clim_summary <- ic %>%
mutate(
year = format(date, "%Y"),
month = format(date, "%m"),
day = format(date, "%d")
) %>%
group_by(year)%>%
summarise(across(
c(colnames(ic)),
list(
min = ~ min(.x, na.rm = TRUE),
max = ~ max(.x, na.rm = TRUE),
avg = ~ mean(.x, na.rm = TRUE),
med = ~ median(.x, na.rm = T)
),
.names = "{.col}_{.fn}"
))
View(clim_summary)
clim_summary <- ic %>%
mutate(
year = format(date, "%Y"),
month = format(date, "%m"),
day = format(date, "%d")
) %>%
group_by(year)%>%
summarise(across(
.cols = where(~ !all(c("date", "year", "month", "day") %in% colnames(ic)) & is.numeric(.)),
list(
min = ~ min(.x, na.rm = TRUE),
max = ~ max(.x, na.rm = TRUE),
avg = ~ mean(.x, na.rm = TRUE),
med = ~ median(.x, na.rm = T)
),
.names = "{.col}_{.fn}"
))
clim_summary_monthly <- ic %>%
mutate(
year = format(date, "%Y"),
month = format(date, "%m"),
day = format(date, "%d")
) %>%
group_by(year, month)%>%
summarise(across(
.cols = where(~ !all(c("date", "year", "month", "day") %in% colnames(ic)) & is.numeric(.)),
list(
min = ~ min(.x, na.rm = TRUE),
max = ~ max(.x, na.rm = TRUE),
avg = ~ mean(.x, na.rm = TRUE),
med = ~ median(.x, na.rm = T)
),
.names = "{.col}_{.fn}"
))
View(clim_summary_monthly)
# Add columns for the latitude and longitude
final_dataset_large <- ic %>%
mutate(lat = coords$lat, lon = coords$lon, location = "Walnut Creek Common Garden")
final_dataset_summarized_year <- clim_summary %>%
mutate(lat = coords$lat, lon = coords$lon, location = "Walnut Creek Common Garden")
final_dataset_summarized_month <- clim_summary_monthly %>%
mutate(lat = coords$lat, lon = coords$lon, location = "Walnut Creek Common Garden")
?getTerraClim
terra_clim_key <- data.frame(
Variable = c("aet", "def", "PDSI", "pet", "ppt", "q", "soil", "srad", "swe", "tmax", "tmin", "vap", "vpd", "ws"),
Description = c(
"Actual Evapotranspiration: The water that has actually evaporated and transpired.",
"Climatic Water Deficit: The unmet water demand in a location.",
"Palmer Drought Severity Index: Measures dryness based on precipitation and temperature.",
"Potential Evapotranspiration: The amount of water that could evaporate and transpire if water supply was sufficient.",
"Precipitation: Total amount of rainfall or snow equivalent in millimeters.",
"Runoff/Streamflow: Surface water leaving an area, typically measured in mm or mÂ³.",
"Soil Moisture: The amount of water in the soil, often expressed as a percentage or volume.",
"Solar Radiation: The amount of solar energy reaching the Earth's surface, measured in watts per square meter.",
"Snow Water Equivalent: The amount of water stored in snowpack, in millimeters.",
"Maximum Temperature: The daily maximum temperature, typically in degrees Celsius.",
"Minimum Temperature: The daily minimum temperature, typically in degrees Celsius.",
"Vapor Pressure: The amount of moisture in the air, measured in kilopascals (kPa).",
"Vapor Pressure Deficit: The difference between the amount of moisture in the air and how much moisture the air can hold when saturated.",
"Wind Speed: The average wind speed over a specified time period, typically measured in meters per second (m/s)."
)
)
library(openxlsx)
datasets <- list(
"TerraClim Variable Key" = terra_clim_key,
"Full Climate Data" = final_dataset_large,
"Yearly Summary" = final_dataset_summarized_year,
"Monthly Summary" = final_dataset_summarized_month
)
# Create a new workbook
wb <- createWorkbook()
# Add each dataset to a new sheet
for (sheet_name in names(datasets)) {
addWorksheet(wb, sheet_name)
writeData(wb, sheet_name, datasets[[sheet_name]])
}
getwd()
# Save the workbook
saveWorkbook(wb, "C:.Users/beabo/OneDrive/Documents/NAU/Cottonwoods/Walnut_Creek_Climate_Data.xlsx", overwrite = TRUE)
# Save the workbook
saveWorkbook(wb, "C:Users/beabo/OneDrive/Documents/NAU/Cottonwoods/Walnut_Creek_Climate_Data.xlsx", overwrite = TRUE)
setwd("C:Users/beabo/OneDrive/Documents/NAU/Cottonwoods/")
setwd("C:Users/beabo/OneDrive/Documents/NAU/Cottonwoods")
getwd()
setwd("C:Users/beabo/OneDrive/Documents/NAU/Cottonwoods")
setwd("C:Users/beabo/OneDrive/Documents/NAU/Cottonwoods")
install.packages("tidyverse", "ratdat")
install.packages(c("tidyverse", "ratdat"))
library(tidyverse)
library(ratdat)
install.packages(c("abind", "antiword", "ape", "arrow", "backports", "bayestestR", "BH", "bit", "bit64", "bitops", "brew", "brio", "broom", "broom.helpers", "bslib", "callr", "car", "cards", "caret", "caTools", "CFtime", "classInt", "cli", "clock", "cluster", "coda", "commonmark", "condMVNorm", "ConsRank", "correlation", "corrplot", "cowplot", "credentials", "crul", "curl", "dataRetrieval", "datawizard", "dbplyr", "dbscan", "deldir", "dendextend", "DEoptimR", "Deriv", "desc", "dials", "diffobj", "doBy", "doFuture", "downlit", "downloader", "easystats", "effectsize", "emmeans", "EnvStats", "estimability", "evaluate", "expm", "fastmatch", "flextable", "fontawesome", "fs", "future", "future.apply", "gargle", "gdata", "gdtools", "geometries", "geometry", "gert", "ggeffects", "ggpattern", "ggplot2", "ggpmisc", "ggpp", "ggrepel", "ggsci", "ggstats", "gh", "gifski", "globals", "glue", "googledrive", "googlesheets4", "gower", "GPfit", "gridpattern", "gtable", "hardhat", "haven", "hexbin", "Hmisc", "httpuv", "httr2", "igraph", "imager", "indicspecies", "insight", "ISOcodes", "janitor", "jpeg", "knitr", "labelled", "later", "lattice", "lava", "leafem", "lightr", "lme4", "lmodel2", "lpSolve", "lubridate", "lwgeom", "magick", "maps", "markdown", "MatrixModels", "metadat", "metafor", "microbenchmark", "mime", "miniUI", "minqa", "modelbased", "multcomp", "multcompView", "mvtnorm", "ndjson", "networkD3", "nloptr", "NLP", "nls.multstart", "officer", "openxlsx", "overlapping", "parallelly", "parameters", "parsnip", "patchwork", "pbkrtest", "pdftools", "performance", "PerformanceAnalytics", "pivottabler", "pkgbuild", "pkgdown", "pkgload", "plotly", "processx", "profvis", "progressr", "promises", "proxyC", "ps", "purrr", "qpdf", "quanteda", "quanteda.textstats", "quantmod", "quantreg", "questionr", "R.oo", "R.utils", "ragg", "randomForest", "raster", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "RcppTOML", "RCurl", "readODS", "readtext", "readxl", "recipes", "recolorize", "rematch", "remotes", "rempsyc", "renv", "report", "reprex", "reticulate", "rgl", "rjson", "rlang", "rmarkdown", "rnaturalearthdata", "RNetCDF", "robustbase", "roxygen2", "rprojroot", "rsample", "rsconnect", "rstudioapi", "sandwich", "sass", "scales", "see", "sessioninfo", "sf", "sfheaders", "shape", "shapr", "shapviz", "shiny", "slam", "sp", "SparseM", "spatialreg", "spData", "spdep", "splus2R", "stars", "storr", "stringdist", "stringi", "systemfonts", "terra", "testthat", "text", "textshaping", "TH.data", "themis", "tidygeocoder", "tidytext", "timechange", "timeDate", "tinytex", "tm", "tmap", "tmaptools", "tune", "tzdb", "units", "usethis", "usmap", "usmapdata", "uuid", "vegan", "VGAM", "viridis", "waldo", "wk", "workflows", "xfun", "xgboost", "XML", "xml2", "xopen", "xts", "yardstick", "yesno", "zip", "zoo"))
install.packages(c("abind", "antiword", "ape", "arrow", "backports", "bayestestR", "BH", "bit", "bit64", "bitops", "brew", "brio", "broom", "broom.helpers", "bslib", "callr", "car", "cards", "caret", "caTools", "CFtime", "classInt", "cli", "clock", "cluster", "coda", "commonmark", "condMVNorm", "ConsRank", "correlation", "corrplot", "cowplot", "credentials", "crul", "curl", "dataRetrieval", "datawizard", "dbplyr", "dbscan", "deldir", "dendextend", "DEoptimR", "Deriv", "desc", "dials", "diffobj", "doBy", "doFuture", "downlit", "downloader", "easystats", "effectsize", "emmeans", "EnvStats", "estimability", "evaluate", "expm", "fastmatch", "flextable", "fontawesome", "fs", "future", "future.apply", "gargle", "gdata", "gdtools", "geometries", "geometry", "gert", "ggeffects", "ggpattern", "ggplot2", "ggpmisc", "ggpp", "ggrepel", "ggsci", "ggstats", "gh", "gifski", "globals", "glue", "googledrive", "googlesheets4", "gower", "GPfit", "gridpattern", "gtable", "hardhat", "haven", "hexbin", "Hmisc", "httpuv", "httr2", "igraph", "imager", "indicspecies", "insight", "ISOcodes", "janitor", "jpeg", "knitr", "labelled", "later", "lattice", "lava", "leafem", "lightr", "lme4", "lmodel2", "lpSolve", "lubridate", "lwgeom", "magick", "maps", "markdown", "MatrixModels", "metadat", "metafor", "microbenchmark", "mime", "miniUI", "minqa", "modelbased", "multcomp", "multcompView", "mvtnorm", "ndjson", "networkD3", "nloptr", "NLP", "nls.multstart", "officer", "openxlsx", "overlapping", "parallelly", "parameters", "parsnip", "patchwork", "pbkrtest", "pdftools", "performance", "PerformanceAnalytics", "pivottabler", "pkgbuild", "pkgdown", "pkgload", "plotly", "processx", "profvis", "progressr", "promises", "proxyC", "ps", "purrr", "qpdf", "quanteda", "quanteda.textstats", "quantmod", "quantreg", "questionr", "R.oo", "R.utils", "ragg", "randomForest", "raster", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "RcppTOML", "RCurl", "readODS", "readtext", "readxl", "recipes", "recolorize", "rematch", "remotes", "rempsyc", "renv", "report", "reprex", "reticulate", "rgl", "rjson", "rlang", "rmarkdown", "rnaturalearthdata", "RNetCDF", "robustbase", "roxygen2", "rprojroot", "rsample", "rsconnect", "rstudioapi", "sandwich", "sass", "scales", "see", "sessioninfo", "sf", "sfheaders", "shape", "shapr", "shapviz", "shiny", "slam", "sp", "SparseM", "spatialreg", "spData", "spdep", "splus2R", "stars", "storr", "stringdist", "stringi", "systemfonts", "terra", "testthat", "text", "textshaping", "TH.data", "themis", "tidygeocoder", "tidytext", "timechange", "timeDate", "tinytex", "tm", "tmap", "tmaptools", "tune", "tzdb", "units", "usethis", "usmap", "usmapdata", "uuid", "vegan", "VGAM", "viridis", "waldo", "wk", "workflows", "xfun", "xgboost", "XML", "xml2", "xopen", "xts", "yardstick", "yesno", "zip", "zoo"))
install.packages(c("abind", "antiword", "ape", "arrow", "backports", "bayestestR", "BH", "bit", "bit64", "bitops", "brew", "brio", "broom", "broom.helpers", "bslib", "callr", "car", "cards", "caret", "caTools", "CFtime", "classInt", "cli", "clock", "cluster", "coda", "commonmark", "condMVNorm", "ConsRank", "correlation", "corrplot", "cowplot", "credentials", "crul", "curl", "dataRetrieval", "datawizard", "dbplyr", "dbscan", "deldir", "dendextend", "DEoptimR", "Deriv", "desc", "dials", "diffobj", "doBy", "doFuture", "downlit", "downloader", "easystats", "effectsize", "emmeans", "EnvStats", "estimability", "evaluate", "expm", "fastmatch", "flextable", "fontawesome", "fs", "future", "future.apply", "gargle", "gdata", "gdtools", "geometries", "geometry", "gert", "ggeffects", "ggpattern", "ggplot2", "ggpmisc", "ggpp", "ggrepel", "ggsci", "ggstats", "gh", "gifski", "globals", "glue", "googledrive", "googlesheets4", "gower", "GPfit", "gridpattern", "gtable", "hardhat", "haven", "hexbin", "Hmisc", "httpuv", "httr2", "igraph", "imager", "indicspecies", "insight", "ISOcodes", "janitor", "jpeg", "knitr", "labelled", "later", "lattice", "lava", "leafem", "lightr", "lme4", "lmodel2", "lpSolve", "lubridate", "lwgeom", "magick", "maps", "markdown", "MatrixModels", "metadat", "metafor", "microbenchmark", "mime", "miniUI", "minqa", "modelbased", "multcomp", "multcompView", "mvtnorm", "ndjson", "networkD3", "nloptr", "NLP", "nls.multstart", "officer", "openxlsx", "overlapping", "parallelly", "parameters", "parsnip", "patchwork", "pbkrtest", "pdftools", "performance", "PerformanceAnalytics", "pivottabler", "pkgbuild", "pkgdown", "pkgload", "plotly", "processx", "profvis", "progressr", "promises", "proxyC", "ps", "purrr", "qpdf", "quanteda", "quanteda.textstats", "quantmod", "quantreg", "questionr", "R.oo", "R.utils", "ragg", "randomForest", "raster", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "RcppTOML", "RCurl", "readODS", "readtext", "readxl", "recipes", "recolorize", "rematch", "remotes", "rempsyc", "renv", "report", "reprex", "reticulate", "rgl", "rjson", "rlang", "rmarkdown", "rnaturalearthdata", "RNetCDF", "robustbase", "roxygen2", "rprojroot", "rsample", "rsconnect", "rstudioapi", "sandwich", "sass", "scales", "see", "sessioninfo", "sf", "sfheaders", "shape", "shapr", "shapviz", "shiny", "slam", "sp", "SparseM", "spatialreg", "spData", "spdep", "splus2R", "stars", "storr", "stringdist", "stringi", "systemfonts", "terra", "testthat", "text", "textshaping", "TH.data", "themis", "tidygeocoder", "tidytext", "timechange", "timeDate", "tinytex", "tm", "tmap", "tmaptools", "tune", "tzdb", "units", "usethis", "usmap", "usmapdata", "uuid", "vegan", "VGAM", "viridis", "waldo", "wk", "workflows", "xfun", "xgboost", "XML", "xml2", "xopen", "xts", "yardstick", "yesno", "zip", "zoo"))
install.packages(c("abind", "antiword", "ape", "arrow", "backports", "bayestestR", "BH", "bit", "bit64", "bitops", "brew", "brio", "broom", "broom.helpers", "bslib", "callr", "car", "cards", "caret", "caTools", "CFtime", "classInt", "cli", "clock", "cluster", "coda", "commonmark", "condMVNorm", "ConsRank", "correlation", "corrplot", "cowplot", "credentials", "crul", "curl", "dataRetrieval", "datawizard", "dbplyr", "dbscan", "deldir", "dendextend", "DEoptimR", "Deriv", "desc", "dials", "diffobj", "doBy", "doFuture", "downlit", "downloader", "easystats", "effectsize", "emmeans", "EnvStats", "estimability", "evaluate", "expm", "fastmatch", "flextable", "fontawesome", "fs", "future", "future.apply", "gargle", "gdata", "gdtools", "geometries", "geometry", "gert", "ggeffects", "ggpattern", "ggplot2", "ggpmisc", "ggpp", "ggrepel", "ggsci", "ggstats", "gh", "gifski", "globals", "glue", "googledrive", "googlesheets4", "gower", "GPfit", "gridpattern", "gtable", "hardhat", "haven", "hexbin", "Hmisc", "httpuv", "httr2", "igraph", "imager", "indicspecies", "insight", "ISOcodes", "janitor", "jpeg", "knitr", "labelled", "later", "lattice", "lava", "leafem", "lightr", "lme4", "lmodel2", "lpSolve", "lubridate", "lwgeom", "magick", "maps", "markdown", "MatrixModels", "metadat", "metafor", "microbenchmark", "mime", "miniUI", "minqa", "modelbased", "multcomp", "multcompView", "mvtnorm", "ndjson", "networkD3", "nloptr", "NLP", "nls.multstart", "officer", "openxlsx", "overlapping", "parallelly", "parameters", "parsnip", "patchwork", "pbkrtest", "pdftools", "performance", "PerformanceAnalytics", "pivottabler", "pkgbuild", "pkgdown", "pkgload", "plotly", "processx", "profvis", "progressr", "promises", "proxyC", "ps", "purrr", "qpdf", "quanteda", "quanteda.textstats", "quantmod", "quantreg", "questionr", "R.oo", "R.utils", "ragg", "randomForest", "raster", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "RcppTOML", "RCurl", "readODS", "readtext", "readxl", "recipes", "recolorize", "rematch", "remotes", "rempsyc", "renv", "report", "reprex", "reticulate", "rgl", "rjson", "rlang", "rmarkdown", "rnaturalearthdata", "RNetCDF", "robustbase", "roxygen2", "rprojroot", "rsample", "rsconnect", "rstudioapi", "sandwich", "sass", "scales", "see", "sessioninfo", "sf", "sfheaders", "shape", "shapr", "shapviz", "shiny", "slam", "sp", "SparseM", "spatialreg", "spData", "spdep", "splus2R", "stars", "storr", "stringdist", "stringi", "systemfonts", "terra", "testthat", "text", "textshaping", "TH.data", "themis", "tidygeocoder", "tidytext", "timechange", "timeDate", "tinytex", "tm", "tmap", "tmaptools", "tune", "tzdb", "units", "usethis", "usmap", "usmapdata", "uuid", "vegan", "VGAM", "viridis", "waldo", "wk", "workflows", "xfun", "xgboost", "XML", "xml2", "xopen", "xts", "yardstick", "yesno", "zip", "zoo"))
library(tidyverse)
library(ratdat)
3+5
15/8
weight_kg <- 55
weight_kg/2
weight_lb <- 2.2*weight_kg
weight_lb
weight_mg <- 3459
print(weight_mg)
weight_oz <- 500*weight_mg
print(weight_oz)
pi <- 3.14159
round(3.14159)
round(pi)
args(round)
round(pi, digits = 2)
round(pi, 2)
weight_g <- c(50, 60, 65, 82)
weight_g
animals <- c("mouse", "rat", "dog")
animals
length(weight_g)
length(animals)
str(weight_g)
str(animals)
weight_g
weight_g <- c(weight_g, 30)
weight_g
weight_g <- c(30, weight_g)
weight_g
write.csv(weight_g, "weights.csv")
write.csv(weight_g, "Downloads/weights.csv")
getwd()
arg(write.csv())
args(write.csv)
library(utils)
num_char <- c(1, 2, 3, "a")
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
tricky <- c(1, 2, 3, "4")
class(char_logical)
class(tricky)
class(char_logical)
num_char <- c(1, 2, 3, "a")
class(num_char)
num_char <- c(1, 2, 3, a)
num_logical <- c(1, 2, 3, TRUE)
class(num_logical)
class(char_logical)
char_logical
class(tricky)
animals
animals <- c(animals, "cat")
animals
animals[2]
str(animals)
animals[c(2, 3)]
animals[c(3, 2)]
animals[3,2]
animals[3,1]
more_animals <- animals[c(1, 2, 4, 3, 1, 2, 3, 4)]
more_animals
weight_g
weight_g[c(TRUE, FALSE, TRUE, F, T, F)]
weight_g[c(T, F,T,F)]
weight_g > 50
weight_g[weight_g>50]
weight_g[weight_g>30 & weight_g<60]
weight_g[weight_g>30 & weight_g<=50]
weight_g[weight_g>30 & weight_g<60]
weight_g[weight_g>30 & weight_g<=60]
weight_g[weight_g>30 & weight_g<60]
weight_g[weight_g<35 | weight_g>50]
weight_g[weight_g == 30]
weight_g[weight_g == 60 | weight_g < 32]
weight_g[weight_g = 60 | weight_g <32]
weight_g[weight_g = 60]
pi <- 3.14
p=3.141111111111111
weight_g[weight_g>30 & weight_g< =60]
weight_g[weight_g>30 & weight_g<60]
animals
animals[animals=="dog"]
animals[animals=="mouse" | animals =="cat"]
sub_animals <- animals[animals=="mouse" | animals =="cat"]
sub_animals
args(str)
?str
?round
test_obj <- c(1,2)
test_obj
weight_mg <- 3459
weight_oz <- 500*weight_mg
print(weight_oz)
print(weight_mg)
pi <- 3.14159
round(3.14159)
round(pi)
args(round)
round(pi, digits = 2)
round(pi, 2)
weight_g <- c(50, 60, 65, 82)
weight_g
animals <- c("mouse", "rat", "dog")
animals
length(weight_g)
length(animals)
str(weight_g)
str(animals)
weight_g
weight_g <- c(weight_g, 30)
weight_g
weight_g <- c(30, weight_g)
weight_g
num_char <- c(1, 2, 3, "a")
num_logical <- c(1, 2, 3, TRUE)
char_logical <- c("a", "b", "c", TRUE)
tricky <- c(1, 2, 3, "4")
class(num_char)
class(num_logical)
class(char_logical)
class(tricky)
animals
animals <- c(animals, "cat")
animals
animals[2]
str(animals)
animals[c(2, 3)]
animals[c(3, 2)]
animals[3,2]
gc()
plant_species_df <- read.csv("Results/plant_info_results.csv")
plant_species_df <- read.csv("plant_info_results.csv")
library(tidyverse)
library(quanteda)
library(rgbif)
library(furrr)
library(janitor)
#Need to go back and remove any abstracts that are just empty.
set.seed(123)
getwd()
getwd()
library(readxl) #read_xlsx
library(janitor) #Cleaning up ds
library(tidyr)
library(dplyr)
library(ggplot2)
library(EnvStats) #Sample sizes
library(viridis) #For darkness plot
library(ggpubr)
theme_set(theme_bw())
#Load in the dataset, 9/10/24
theme_set(theme_bw())
ds <- read_xlsx("C:/Users/beabo/OneDrive/Documents/NAU/Misc/Lexie Aa Dark Light 2024/Data 2.xlsx", sheet = 3)
ds <- clean_names(ds) #Making the column names easier to work with
# Function to calculate darkness from a hex code without #
calculate_darkness <- function(hex_color) {
# Add # to the hex code if it's missing
if (!startsWith(hex_color, "#")) {
hex_color <- paste0("#", hex_color)
}
# Convert hex to RGB
rgb <- col2rgb(hex_color) / 255
# Calculate luminance (perceived brightness)
luminance <- 0.2126 * rgb[1, ] + 0.7152 * rgb[2, ] + 0.0722 * rgb[3, ]
# Darkness is the inverse of luminance (1 - luminance)
darkness <- 1 - luminance
return(darkness)
}
ds <- ds %>% #Rounding the C so that it's grouped
mutate(C_ml = round(c_g_m_l, digits = 3),
darkness = sapply(average_hex_fungus, calculate_darkness),
Treatment = case_when(
n_m_l == 2 & C_ml == 0.002 ~ "Low N Low C",
n_m_l == 2 & C_ml == 0.01  ~ "Low N High C",
n_m_l == 6 & C_ml == 0.002 ~ "High N Low C",
n_m_l == 6 & C_ml == 0.01  ~ "High N High C",
TRUE ~ NA_character_  # Default case if no conditions match
),
c_to_n = c_in_each_box_moles/n_in_each_box_moles)
ds <- read_xlsx("C:/Users/beabo/OneDrive/Documents/NAU/Misc/Lexie Aa Dark Light 2024/Data 2.xlsx", sheet = 3)
ds <- clean_names(ds) #Making the column names easier to work with
ds[which(ds$average_hex_fungus == "917862.0"),]$average_hex_fungus <- "917862"
# Function to calculate darkness from a hex code without #
calculate_darkness <- function(hex_color) {
# Add # to the hex code if it's missing
if (!startsWith(hex_color, "#")) {
hex_color <- paste0("#", hex_color)
}
# Convert hex to RGB
rgb <- col2rgb(hex_color) / 255
# Calculate luminance (perceived brightness)
luminance <- 0.2126 * rgb[1, ] + 0.7152 * rgb[2, ] + 0.0722 * rgb[3, ]
# Darkness is the inverse of luminance (1 - luminance)
darkness <- 1 - luminance
return(darkness)
}
ds <- ds %>% #Rounding the C so that it's grouped
mutate(C_ml = round(c_g_m_l, digits = 3),
darkness = sapply(average_hex_fungus, calculate_darkness),
Treatment = case_when(
n_m_l == 2 & C_ml == 0.002 ~ "Low N Low C",
n_m_l == 2 & C_ml == 0.01  ~ "Low N High C",
n_m_l == 6 & C_ml == 0.002 ~ "High N Low C",
n_m_l == 6 & C_ml == 0.01  ~ "High N High C",
TRUE ~ NA_character_  # Default case if no conditions match
),
c_to_n = c_in_each_box_moles/n_in_each_box_moles)
ggplot(ds, aes(x = factor(C_ml), y = shoot_mass_g))+
geom_boxplot()+
labs(title = "Higher C = Higher biomass")
ggplot(ds, aes(x = factor(n_m_l), y = shoot_mass_g))+
geom_boxplot()+
labs(title = "Higher N = ??")
ggplot(ds, aes(x = factor(C_ml), y = shoot_mass_g))+
geom_boxplot()+
labs(title = "HighN + LowC = Lowest biomass")+
facet_grid(~n_m_l)
ggplot(ds, aes(x = factor(c_in_each_box_moles), y = shoot_mass_g))+
geom_boxplot()+
labs(title = "HighN + LowC = Lowest biomass")+
facet_grid(~n_m_l)
summary(aov(shoot_mass_g ~ C_ml*n_m_l, ds))
ggplot(ds, aes(x = diameter_cm, y = shoot_mass_g))+
geom_point()+
# geom_smooth()+
facet_grid(C_ml~n_m_l)+
labs(title = "diameter v shoot mass")
ggplot(ds, aes(x = factor(C_ml), y = diameter_cm))+
geom_boxplot()+
facet_grid(~n_m_l)+
labs(title = "Higher N = Higher diameter")
summary(aov(diameter_cm ~ C_ml*n_m_l, ds))
ggplot(ds, aes(x = factor(C_ml), y = approximate_fungal_mass_g))+
geom_boxplot()+
facet_grid(~n_m_l)+
labs(title = "Higher N = Higher fungal mass")
#Darker fungi are bigger, and the darker/bigger fungi are the ones in the lower C treatment
ds%>%
ggplot(aes(y = diameter_cm, x= rank_of_hex_from_light_to_dark, color = factor(C_ml)))+
geom_point()+
geom_smooth(method = "lm")
ds%>%
ggplot(aes(y = diameter_cm, x= darkness, color = factor(C_ml)))+
geom_point()+
geom_smooth(method = "lm")+
labs(x = "Average darkness of fungus")
ds%>%
ggplot(aes(y = shoot_mass_g, x= darkness, color = factor(C_ml)))+
geom_point()+
geom_smooth(method = "lm")+
labs(x = "Average darkness of fungus")
ds%>%
ggplot(aes(y = shoot_mass_g, x= darkness, color = factor(n_m_l)))+
geom_point()+
geom_smooth(method = "lm")+
labs(x = "Average darkness of fungus")
ds%>%
ggplot(aes(y = diameter_cm, x= darkness, color = factor(n_m_l)))+
geom_point()+
geom_smooth(method = "lm")+
labs(x = "Average darkness of fungus")
ds%>%
ggplot(aes(y = shoot_mass_g, x= darkness, color = Treatment))+
geom_point()+
geom_smooth(method = "lm")+
labs(x = "Average darkness of fungus")
ds%>%
ggplot(aes(y = approximate_fungal_mass_g, x= diameter_cm, color = Treatment))+
geom_point()+
geom_smooth(method = "lm")+
labs(x = "Average darkness of fungus")
ds%>%
ggplot(aes(y = darkness, x= diameter_cm, color = Treatment))+
geom_point()+
geom_smooth(method = "lm")
ds%>%
ggplot(aes(x = darkness, y= shoot_mass_g, color = factor(n_m_l)))+
geom_point()+
geom_smooth(method = "lm")
model <- lm(data=ds, shoot_mass_g ~ darkness*C_ml*diameter_cm)
summary(model)
ds %>%
ggplot(aes(x = c_to_n, y = shoot_mass_g))+
geom_smooth()+
geom_point()#+
ds %>%
ggplot(aes(x = c_to_n, y = shoot_mass_g))+
geom_smooth()+
geom_point()+
scale_color_viridis(option = "A", direction = -1)
ds %>%
ggplot(aes(x = moles_c_to_moles_n, y = shoot_mass_g))+
geom_smooth()+
geom_point(aes(color = darkness))+
labs(x = "moles of C/moles of N")+
scale_color_viridis(option = "A", direction = -1)
**Beatrice M. Bock**^1^
setwd("C:/Users/beabo/OneDrive - Northern Arizona University/NAU/biobert_dualsolo")
setwd("C:/Users/beabo/OneDrive - Northern Arizona University/NAU/biobert_dualsolo")
